package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"

	"github.com/bigmikesolutions/wingman/graphql/generated"
	"github.com/bigmikesolutions/wingman/graphql/graphqlctx"
	"github.com/bigmikesolutions/wingman/graphql/model"
	"github.com/bigmikesolutions/wingman/graphql/model/cursor"
	"github.com/bigmikesolutions/wingman/providers/db/conv"
)

// Info is the resolver for the info field.
func (r *databaseResolver) Info(ctx context.Context, obj *model.Database) (*model.DatabaseInfo, error) {
	env, err := graphqlctx.Environment(ctx)
	if err != nil {
		return nil, err
	}

	info, err := r.Providers.DB.Info(ctx, env, obj.ID)
	if err != nil {
		return nil, err
	}
	if info == nil {
		return nil, nil
	}

	return &model.DatabaseInfo{
		ID:     info.ID,
		Driver: model.DriverTypePostgres,
		Host:   info.Host,
		Port:   info.Port,
	}, nil
}

// Table is the resolver for the table field.
func (r *databaseResolver) Table(ctx context.Context, obj *model.Database, name string, first *int, after *cursor.Cursor, where *model.TableFilter) (*model.TableDataConnection, error) {
	env, err := graphqlctx.Environment(ctx)
	if err != nil {
		return nil, err
	}

	// TODO finalise logic implementation here
	db, err := r.Providers.DB.Connection(ctx, env, obj.ID)
	if err != nil {
		return nil, err
	}

	// TODO use nice & safe DQL builder here
	if first == nil {
		v := 50
		first = &v
	}
	rows, err := db.SelectFromTable(ctx, name, *first)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.TableDataEdge, 0)
	idx := 0
	for rows.Next() {
		v, err := rows.SliceScan()
		if err != nil {
			return nil, err
		}

		rowNr := idx
		r := model.TableDataEdge{
			Cursor: "", // TODO add cursor support here
			Node: &model.TableRow{
				Index:  &rowNr,
				Values: make([]*string, len(v)),
			},
		}

		for i, v := range v {
			s := fmt.Sprintf("%v", v)
			r.Node.Values[i] = &s
		}

		edges = append(edges, &r)
		idx++
	}

	return &model.TableDataConnection{
		ConnectionInfo: &model.ConnectionInfo{
			HasNextPage: false,
		},
		Edges: edges,
	}, nil
}

// Database is the resolver for the database field.
func (r *environmentResolver) Database(ctx context.Context, obj *model.Environment, id string) (*model.Database, error) {
	return &model.Database{
		ID: id,
	}, nil
}

// AddDatabase is the resolver for the addDatabase field.
func (r *mutationResolver) AddDatabase(ctx context.Context, input model.AddDatabaseInput) (*model.AddDatabasePayload, error) {
	info := conv.InputToInfo(input)

	err := r.Providers.DB.Register(ctx, info)
	if err != nil {
		return nil, err
	}

	return &model.AddDatabasePayload{
		MutationID: input.MutationID,
		ID:         info.ID,
	}, nil
}

// Database is the resolver for the database field.
func (r *resourceGrantInputResolver) Database(ctx context.Context, obj *model.ResourceGrantInput, data []*model.DatabaseResource) error {
	// TODO implement this
	event := r.reqLog(ctx).With().
		Any("request.input", obj).
		Any("request.data", data).
		Logger()

	for _, d := range data {
		if d.Info != nil {
			switch *d.Info {
			case model.AccessTypeReadOnly:
				if err := r.Providers.DbRbac.ReadInfo(ctx, obj.Env, d.ID); err != nil {
					event.Info().Err(err).Msg("Database access denied")
					return err
				}
			}
		}
	}

	event.Debug().Msg("Database access granted")
	return nil
}

// Database returns generated.DatabaseResolver implementation.
func (r *Resolver) Database() generated.DatabaseResolver { return &databaseResolver{r} }

type databaseResolver struct{ *Resolver }
