package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.60

import (
	"context"
	"fmt"
	"log"

	"github.com/bigmikesolutions/wingman/graphql/generated"
	"github.com/bigmikesolutions/wingman/graphql/model"
	"github.com/bigmikesolutions/wingman/graphql/model/cursor"
)

// Info is the resolver for the info field.
func (r *databaseResolver) Info(ctx context.Context, obj *model.Database) (*model.DatabaseInfo, error) {
	info, err := r.Providers.DB.Info(ctx, obj.ID)
	if err != nil {
		return nil, err
	}
	if info == nil {
		// TODO return user friendly client error here
		return nil, nil
	}

	return &model.DatabaseInfo{
		ID:     info.ID,
		Driver: model.DriverTypePostgres,
		Host:   info.Host,
		Port:   info.Port,
	}, nil
}

// Table is the resolver for the table field.
func (r *databaseResolver) Table(ctx context.Context, obj *model.Database, name string, first *int, after *cursor.Cursor, where *model.TableFilter) (*model.TableDataConnection, error) {
	// TODO finalise logic implementation here
	db, err := r.Providers.DB.Connection(ctx, obj.ID)
	if err != nil {
		return nil, err
	}

	// TODO use nice & safe DQL builder here
	if first == nil {
		v := 50
		first = &v
	}
	rows, err := db.SelectFromTable(ctx, name, *first)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.TableDataEdge, 0)
	idx := 0
	for rows.Next() {
		v, err := rows.SliceScan()
		if err != nil {
			return nil, err
		}

		rowNr := idx
		r := model.TableDataEdge{
			Cursor: "", // TODO add cursor support here
			Node: &model.TableRow{
				Index:  &rowNr,
				Values: make([]*string, len(v)),
			},
		}

		for i, v := range v {
			s := fmt.Sprintf("%v", v)
			r.Node.Values[i] = &s
		}

		edges = append(edges, &r)
		idx++
	}

	return &model.TableDataConnection{
		ConnectionInfo: &model.ConnectionInfo{
			HasNextPage: false,
		},
		Edges: edges,
	}, nil
}

// Database is the resolver for the database field.
func (r *environmentResolver) Database(ctx context.Context, obj *model.Environment, id string) (*model.Database, error) {
	// TODO implement this stub
	return &model.Database{
		ID: id,
	}, nil
}

// Database is the resolver for the database field.
func (r *resourceGrantInputResolver) Database(ctx context.Context, obj *model.ResourceGrantInput, data []*model.DatabaseResource) error {
	// TODO implement this
	log.Printf("Database grant...")

	return nil
}

// Database returns generated.DatabaseResolver implementation.
func (r *Resolver) Database() generated.DatabaseResolver { return &databaseResolver{r} }

type databaseResolver struct{ *Resolver }
